/*
 * XMLUtils.java
 *
 * Copyright (c) 2002 David Zwarg <david.zwarg@gmail.com>
 *
 * See LICENSE in the project root for copying permission.
 */

package com.zwarg.vocab;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import java.io.File;
import java.io.IOException;

import java.lang.IllegalArgumentException;
import java.lang.Exception;
import java.lang.String;

/**
 *
 * @author davidz
 * @version 1.0
 */
public class XMLUtils {

    /** Creates new XMLUtils */
    public XMLUtils()
    {
        factory = DocumentBuilderFactory.newInstance();
        try
        {
            builder = factory.newDocumentBuilder();
            document = builder.newDocument();
        }
        catch (ParserConfigurationException pce)
        {
            // Parser with specified options can't be built
            pce.printStackTrace();
        }
    }

    public void newXMLDocument()
    {
        root = (Element) document.createElement("vocabularylist");
        document.appendChild(root);
    }

    public void openXMLDocument(String filename)
    {
        try
        {
           builder = factory.newDocumentBuilder();
           document = builder.parse( new File( filename ) );
        }
        catch (SAXException sxe)
        {
           // Error generated during parsing)
           Exception  x = sxe;
           if (sxe.getException() != null)
               x = sxe.getException();
           x.printStackTrace();
        }
        catch (ParserConfigurationException pce)
        {
            // Parser with specified options can't be built
            pce.printStackTrace();
        }
        catch (IOException ioe)
        {
           // I/O error
           ioe.printStackTrace();
        }
    }

    public void writeXMLDocument(String filename)
    {
        try
        {
            // Use a Transformer for output
            TransformerFactory tFactory = TransformerFactory.newInstance();
            Transformer transformer = tFactory.newTransformer();

            DOMSource source = new DOMSource(document);
            StreamResult result = new StreamResult( new File(filename) );
            transformer.transform(source, result);

        }
        catch (TransformerConfigurationException tce)
        {
            // Error generated by the parser
            System.out.println ("\n** Transformer Factory error");
            System.out.println("   " + tce.getMessage() );

            // Use the contained exception, if any
            Throwable x = tce;
            if (tce.getException() != null) x = tce.getException();
            x.printStackTrace();
        }
        catch (TransformerException te)
        {
            // Error generated by the parser
            System.out.println ("\n** Transformation error");
            System.out.println("   " + te.getMessage() );

            // Use the contained exception, if any
            Throwable x = te;
            if (te.getException() != null) x = te.getException();
            x.printStackTrace();
        }
    }

    public void addXMLNode( String strWord, String strDefinition )
    {
        boolean found = false;
        int fndIndex = 0;

        root = document.getDocumentElement();
        words = document.getElementsByTagName("word");

        for (int i=0;i<words.getLength();i++)
        {
            tmp = (Element) words.item(i);

            if ( tmp.getAttributeNode("value").getValue().equals(new String(strWord)) )
            {
                found = true;
                fndIndex = i;
            }
        }

        if (found)
        {
            oldword = (Element) words.item( fndIndex );
            word = (Element) words.item( fndIndex ).cloneNode(true);
        }
        else
        {
            word = document.createElement("word");
            word.setAttribute( "value", strWord );
        }

        def = document.createElement("def");
        txt = document.createTextNode( strDefinition );

        def.appendChild( txt );
        word.appendChild( def );
        if (!found)
        {
            root.appendChild( word );
        }
        else
        {
            old = root.replaceChild( word, oldword );
        }

        root.normalize();
    }

    public int countNodes(String strNodeName)
    {
        words = document.getElementsByTagName( strNodeName );
        return words.getLength();
    }

    public int countSubNodes( int wordNodeNum )
    {
        words = document.getElementsByTagName( "word" );
        tmp = (Element) words.item( wordNodeNum );

        defs = tmp.getElementsByTagName( "def" );
        return defs.getLength();
    }

    public String getSubNode( int masterNode, int childNode )
    {
        words = document.getElementsByTagName( "word" );
        tmp = (Element) words.item( masterNode );

        defs = tmp.getElementsByTagName( "def" );
        tmp = (Element) defs.item( childNode );

        defs = tmp.getChildNodes();
        txt = (Text) defs.item( 0 );

        return txt.getData();
    }

    public void removeXMLNode( String strWord )
    {
        root = document.getDocumentElement();
        words = document.getElementsByTagName("word");

        for (int i=0;i<words.getLength();i++)
        {
            tmp = (Element) words.item(i);

            if ( tmp.getAttributeNode("value").getValue().equals(new String(strWord)) )
            {
                old = root.removeChild( tmp );
            }
        }
    }

    public String getWord( int wordNum )
    {
        root = document.getDocumentElement();
        words = document.getElementsByTagName("word");
        tmp = (Element) words.item( wordNum );
        return tmp.getAttributeNode("value").getValue();
    }

    private Document document;
    private DocumentBuilder builder;
    private DocumentBuilderFactory factory;
    private Element root, word, oldword, def, tmp;
    private Text txt;
    private Node old;
    private NodeList words, defs;
}
